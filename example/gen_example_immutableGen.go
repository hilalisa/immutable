// Copyright (c) 2016 Paul Jolly <paul@myitcv.org.uk>, all rights reserved.
// Use of this document is governed by a license found in the LICENSE document.

// File generated by immutableGen

package example

//go:generate echo "hello world"

import (
	"github.com/myitcv/immutable"
)

// MyMap will be exported
//
// MyMap is an immutable type and has the following template:
//
// 	map[string]MySlice
//
type MyMap struct {
	//github.com/myitcv/immutable:ImmutableType

	theMap  map[string]MySlice
	mutable bool
}

var _ immutable.Immutable = &MyMap{}

func NewMyMap() *MyMap {
	return &MyMap{
		theMap: make(map[string]MySlice),
	}
}

func NewMyMapLen(l int) *MyMap {
	return &MyMap{
		theMap: make(map[string]MySlice, l),
	}
}

func (m *MyMap) Mutable() bool {
	return m.mutable
}

func (m *MyMap) Len() int {
	if m == nil {
		return 0
	}

	return len(m.theMap)
}

func (m *MyMap) Get(k string) (MySlice, bool) {
	v, ok := m.theMap[k]
	return v, ok
}

func (m *MyMap) AsMutable() *MyMap {
	if m == nil {
		return nil
	}

	res := m.dup()
	res.mutable = true

	return res
}

func (m *MyMap) dup() *MyMap {
	resMap := make(map[string]MySlice, len(m.theMap))

	for k := range m.theMap {
		resMap[k] = m.theMap[k]
	}

	res := &MyMap{
		theMap: resMap,
	}

	return res
}

func (m *MyMap) AsImmutable() *MyMap {
	if m == nil {
		return nil
	}

	m.mutable = false

	return m
}

func (m *MyMap) Range() map[string]MySlice {
	if m == nil {
		return nil
	}

	return m.theMap
}

func (m *MyMap) WithMutations(f func(mi *MyMap)) *MyMap {
	res := m.AsMutable()
	f(res)
	res = res.AsImmutable()

	return res
}

func (m *MyMap) Set(k string, v MySlice) *MyMap {
	if m.mutable {
		m.theMap[k] = v
		return m
	}

	res := m.dup()
	res.theMap[k] = v

	return res
}

func (m *MyMap) Del(k string) *MyMap {
	if _, ok := m.theMap[k]; !ok {
		return m
	}

	if m.mutable {
		delete(m.theMap, k)
		return m
	}

	res := m.dup()
	delete(res.theMap, k)

	return res
}

// MySlice will be exported
//
// MySlice is an immutable type and has the following template:
//
// 	[]MyMap
//
type MySlice struct {
	//github.com/myitcv/immutable:ImmutableType

	theSlice []MyMap
	mutable  bool
}

var _ immutable.Immutable = &MySlice{}

func NewMySlice(s ...MyMap) *MySlice {
	c := make([]MyMap, len(s))
	copy(c, s)

	return &MySlice{
		theSlice: c,
	}
}

func NewMySliceLen(l int) *MySlice {
	c := make([]MyMap, l)

	return &MySlice{
		theSlice: c,
	}
}

func (m *MySlice) Mutable() bool {
	return m.mutable
}

func (m *MySlice) Len() int {
	if m == nil {
		return 0
	}

	return len(m.theSlice)
}

func (m *MySlice) Get(i int) MyMap {
	return m.theSlice[i]
}

func (m *MySlice) AsMutable() *MySlice {
	if m == nil {
		return nil
	}

	res := m.dup()
	res.mutable = true

	return res
}

func (m *MySlice) dup() *MySlice {
	resSlice := make([]MyMap, len(m.theSlice))

	for i := range m.theSlice {
		resSlice[i] = m.theSlice[i]
	}

	res := &MySlice{
		theSlice: resSlice,
	}

	return res
}

func (m *MySlice) AsImmutable() *MySlice {
	if m == nil {
		return nil
	}

	m.mutable = false

	return m
}

func (m *MySlice) Range() []MyMap {
	if m == nil {
		return nil
	}

	return m.theSlice
}

func (m *MySlice) WithMutations(f func(mi *MySlice)) *MySlice {
	res := m.AsMutable()
	f(res)
	res = res.AsImmutable()

	// TODO optimise here if the maps are identical?

	return res
}

func (m *MySlice) Set(i int, v MyMap) *MySlice {
	if m.mutable {
		m.theSlice[i] = v
		return m
	}

	res := m.dup()
	res.theSlice[i] = v

	return res
}

func (m *MySlice) Append(v ...MyMap) *MySlice {
	if m.mutable {
		m.theSlice = append(m.theSlice, v...)
		return m
	}

	res := m.dup()
	res.theSlice = append(res.theSlice, v...)

	return res
}

// MyStruct will be exported.
//
// It is a special type.
//
// MyStruct is an immutable type and has the following template:
//
// 	struct {
// 		Name	string
//
// 		surname	string
//
// 		age	int
// 	}
//
type MyStruct struct {
	//github.com/myitcv/immutable:ImmutableType

	_Name    string `tag:"value"`
	_surname string
	_age     int `tag:"age"`

	mutable bool
}

var _ immutable.Immutable = &MyStruct{}

func (s *MyStruct) AsMutable() *MyStruct {
	res := *s
	res.mutable = true
	return &res
}

func (s *MyStruct) AsImmutable() *MyStruct {
	s.mutable = false
	return s
}

func (s *MyStruct) Mutable() bool {
	return s.mutable
}

func (s *MyStruct) WithMutations(f func(si *MyStruct)) *MyStruct {
	res := s.AsMutable()
	f(res)
	res = res.AsImmutable()

	return res
}

// Name is a field in MyStruct
func (s *MyStruct) Name() string {
	return s._Name
}

// SetName is the setter for Name()
func (s *MyStruct) SetName(n string) *MyStruct {
	if s.mutable {
		s._Name = n
		return s
	}

	res := *s
	res._Name = n
	return &res
}

// surname will not be exported
func (s *MyStruct) surname() string {
	return s._surname
}

// setSurname is the setter for Surname()
func (s *MyStruct) setSurname(n string) *MyStruct {
	if s.mutable {
		s._surname = n
		return s
	}

	res := *s
	res._surname = n
	return &res
}

// age will not be exported
func (s *MyStruct) age() int {
	return s._age
}

// setAge is the setter for Age()
func (s *MyStruct) setAge(n int) *MyStruct {
	if s.mutable {
		s._age = n
		return s
	}

	res := *s
	res._age = n
	return &res
}
